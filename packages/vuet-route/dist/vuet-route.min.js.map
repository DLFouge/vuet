{"version":3,"file":"vuet-route.min.js","sources":["../src/index.js","../../../src/vuet-static.js","../../../src/debug.js"],"sourcesContent":["import debug from '../../../src/debug'\n// import util from '../../../src/util'\n\nconst NAME = '__route__'\n\nfunction isWatch (vuet, path, route) {\n  const vtm = vuet.getModule(path)\n  let watch = vtm.route.watch || ['fullPath']\n  watch = Array.isArray(watch) ? watch : [watch]\n  const oldWatch = vuet[NAME][path]\n  vuet[NAME][path] = []\n  watch.forEach(k => {\n    let data = route\n    k.split('.').forEach(chlidKey => {\n      data = data[chlidKey]\n    })\n    vuet[NAME][path].push(JSON.stringify(data))\n  })\n  return oldWatch.join() !== vuet[NAME][path].join()\n}\n\nfunction resetVuetScroll (vtm) {\n  const { $scroll } = vtm.state\n  if ($scroll) {\n    Object.keys($scroll).forEach(k => {\n      $scroll[k].x = 0\n      $scroll[k].y = 0\n    })\n  }\n}\n\nexport default {\n  init (vuet) {\n    vuet[NAME] = {}\n  },\n  addModule (vuet, path) {\n    vuet[NAME][path] = []\n    const vtm = vuet.getModule(path)\n    Object.keys(vtm.route).forEach(k => {\n      if (typeof vtm.route[k] === 'function') {\n        vtm.route[k] = vtm.route[k].bind(vtm)\n      }\n    })\n  },\n  rule ({ path }) {\n    return {\n      beforeCreate () {\n        debug.assertModule(this.$vuet, path)\n        const vtm = this.$vuet.getModule(path)\n        if (isWatch(this.$vuet, path, this.$route)) {\n          vtm.reset()\n          resetVuetScroll(vtm)\n        }\n        vtm.route.fetch(vtm)\n      },\n      watch: {\n        $route: {\n          deep: true,\n          handler (to, from) {\n            const vtm = this.$vuet.getModule(path)\n            if (isWatch(this.$vuet, path, to)) {\n              vtm.reset()\n              resetVuetScroll(vtm)\n            }\n            vtm.route.fetch(vtm)\n          }\n        }\n      }\n    }\n  }\n}\n","import debug from './debug'\nimport util from './util'\n\nexport let _Vue\n\nexport default function (Vuet) {\n  Object.assign(Vuet, {\n    installed: false,\n    options: {\n      rules: {}\n    },\n    install (Vue) {\n      if (this.installed) return this\n      this.installed = true\n      _Vue = Vue\n      Object.defineProperty(Vue.prototype, '$vuet', {\n        get () { return this.$root._vuet }\n      })\n      Vue.mixin({\n        beforeCreate () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet = this.$options.vuet\n              this._vuet._init(this)\n            }\n          }\n        },\n        destroyed () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet.destroy(this)\n            }\n          }\n        }\n      })\n      return this\n    },\n    mapModules (opts) {\n      const mixins = Object.keys(opts).map(alias => {\n        const path = opts[alias]\n        return {\n          computed: {\n            [alias]: {\n              get () {\n                debug.assertModule(this.$vuet, path)\n                return this.$vuet.getModule(path)\n              },\n              set (val) {\n                debug.error(`The'${path}'module is not allowed to assign`)\n              }\n            }\n          }\n        }\n      })\n      return {\n        mixins\n      }\n    },\n    mapRules () {\n      const opts = util.getArgMerge.apply(null, arguments)\n      const vueRules = []\n      const addRule = (ruleName, any) => {\n        const rules = Vuet.options.rules[ruleName]\n        if (!util.isObject(rules)) debug.error(`The'${ruleName}'rule does not exist. Please make sure that it executes 'Vuet.rule('${ruleName}', opts)' before all components`)\n        if (typeof any === 'string') {\n          vueRules.push(rules.rule({ path: any }))\n        } else {\n          vueRules.push(rules.rule(any))\n        }\n      }\n      Object.keys(opts).forEach(ruleName => {\n        const any = opts[ruleName]\n        if (Array.isArray(any)) {\n          return any.forEach(item => {\n            addRule(ruleName, item)\n          })\n        }\n        addRule(ruleName, any)\n      })\n      return {\n        mixins: vueRules\n      }\n    },\n    rule () {\n      Vuet.options.rules[arguments[0]] = arguments[1]\n      if (typeof arguments[1].install === 'function') {\n        arguments[1].install(Vuet, _Vue)\n      }\n      return this\n    },\n    callRuleHook (hook, ...arg) {\n      Object.keys(Vuet.options.rules).forEach(k => {\n        if (typeof Vuet.options.rules[k][hook] === 'function') {\n          Vuet.options.rules[k][hook].apply(undefined, arg)\n        }\n      })\n    }\n  })\n}\n","import { _Vue } from './vuet-static'\n\nexport default {\n  error (msg) {\n    throw new Error(`[vuet] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[vuet] ${msg}`)\n    }\n  },\n  assertModule (vuet, name) {\n    if (name in vuet.modules) {\n      return\n    }\n    this.error(`The '${name}' module does not exist`)\n  },\n  assertVue () {\n    if (!_Vue) {\n      this.error('must call Vue.use(Vuet) before creating a store instance')\n    }\n  },\n  assertPromise () {\n    if (typeof Promise === 'undefined') {\n      this.error('Vuet requires a Promise polyfill in this browser')\n    }\n  }\n}\n"],"names":["isWatch","vuet","path","route","vtm","getModule","watch","Array","isArray","oldWatch","NAME","forEach","data","split","chlidKey","push","JSON","stringify","join","resetVuetScroll","$scroll","state","keys","k","x","y","msg","Error","name","modules","error","Promise","bind","assertModule","this","$vuet","$route","reset","fetch","to","from"],"mappings":"wMAKA,SAASA,GAASC,EAAMC,EAAMC,MACtBC,GAAMH,EAAKI,UAAUH,GACvBI,EAAQF,EAAID,MAAMG,QAAU,cACxBC,MAAMC,QAAQF,GAASA,GAASA,MAClCG,GAAWR,EAAKS,GAAMR,YACvBQ,GAAMR,QACLS,QAAQ,eACRC,GAAOT,IACTU,MAAM,KAAKF,QAAQ,cACZC,EAAKE,OAETJ,GAAMR,GAAMa,KAAKC,KAAKC,UAAUL,MAEhCH,EAASS,SAAWjB,EAAKS,GAAMR,GAAMgB,OAG9C,QAASC,GAAiBf,MAChBgB,GAAYhB,EAAIiB,MAAhBD,OACJA,WACKE,KAAKF,GAAST,QAAQ,cACnBY,GAAGC,EAAI,IACPD,GAAGE,EAAI,ICvBd,sBCAEC,QACC,IAAIC,iBAAgBD,kBAEtBA,2BAKQzB,EAAM2B,GACdA,IAAQ3B,GAAK4B,cAGZC,cAAcF,wDAIZE,MAAM,sFAIU,mBAAZC,eACJD,MAAM,sDFrBXpB,EAAO,6BA6BLT,KACCS,0BAEIT,EAAMC,KACVQ,GAAMR,SACLE,GAAMH,EAAKI,UAAUH,UACpBoB,KAAKlB,EAAID,OAAOQ,QAAQ,YACD,kBAAjBP,GAAID,MAAMoB,OACfpB,MAAMoB,GAAKnB,EAAID,MAAMoB,GAAGS,KAAK5B,2BAI/BF,KAAAA,sCAGI+B,aAAaC,KAAKC,MAAOjC,MACzBE,GAAM8B,KAAKC,MAAM9B,UAAUH,EAC7BF,GAAQkC,KAAKC,MAAOjC,EAAMgC,KAAKE,YAC7BC,UACYjC,MAEdD,MAAMmC,MAAMlC,yBAIR,mBACGmC,EAAIC,MACLpC,GAAM8B,KAAKC,MAAM9B,UAAUH,EAC7BF,GAAQkC,KAAKC,MAAOjC,EAAMqC,OACxBF,UACYjC,MAEdD,MAAMmC,MAAMlC"}