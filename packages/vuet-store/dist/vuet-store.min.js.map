{"version":3,"file":"vuet-store.min.js","sources":["../../../src/vuet-static.js","../../../src/debug.js","../src/index.js"],"sourcesContent":["import debug from './debug'\nimport util from './util'\n\nexport let _Vue\n\nexport default function (Vuet) {\n  Object.assign(Vuet, {\n    installed: false,\n    options: {\n      rules: {},\n      module: {\n        reset () {\n          this.state = this.data()\n          return this\n        }\n      }\n    },\n    install (Vue) {\n      if (this.installed) return this\n      this.installed = true\n      _Vue = Vue\n      Object.defineProperty(Vue.prototype, '$vuet', {\n        get () { return this.$root._vuet }\n      })\n      Vue.mixin({\n        beforeCreate () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet = this.$options.vuet\n              this._vuet._init(this)\n            }\n          }\n        },\n        destroyed () {\n          if (typeof this.$options.vuet !== 'undefined') {\n            if (this.$options.vuet instanceof Vuet) {\n              this._vuet.destroy(this)\n            }\n          }\n        }\n      })\n      return this\n    },\n    mapModules (opts) {\n      const mixins = Object.keys(opts).map(alias => {\n        const path = opts[alias]\n        return {\n          computed: {\n            [alias]: {\n              get () {\n                debug.assertModule(this.$vuet, path)\n                return this.$vuet.getModule(path)\n              },\n              set (val) {\n                debug.error(`The'${path}'module is not allowed to assign`)\n              }\n            }\n          }\n        }\n      })\n      return {\n        mixins\n      }\n    },\n    mapRules () {\n      const opts = util.getArgMerge.apply(null, arguments)\n      const vueRules = []\n      const addRule = (ruleName, any) => {\n        const rules = Vuet.options.rules[ruleName]\n        if (!util.isObject(rules)) debug.error(`The'${ruleName}'rule does not exist. Please make sure that it executes 'Vuet.rule('${ruleName}', opts)' before all components`)\n        if (typeof any === 'string') {\n          vueRules.push(rules.rule({ path: any }))\n        } else {\n          vueRules.push(rules.rule(any))\n        }\n      }\n      Object.keys(opts).forEach(ruleName => {\n        const any = opts[ruleName]\n        if (Array.isArray(any)) {\n          return any.forEach(item => {\n            addRule(ruleName, item)\n          })\n        }\n        addRule(ruleName, any)\n      })\n      return {\n        mixins: vueRules\n      }\n    },\n    rule () {\n      Vuet.options.rules[arguments[0]] = arguments[1]\n      if (typeof arguments[1].install === 'function') {\n        arguments[1].install(Vuet, _Vue)\n      }\n      return this\n    },\n    callRuleHook (hook, ...arg) {\n      Object.keys(Vuet.options.rules).forEach(k => {\n        if (typeof Vuet.options.rules[k][hook] === 'function') {\n          Vuet.options.rules[k][hook].apply(undefined, arg)\n        }\n      })\n    }\n  })\n}\n","import { _Vue } from './vuet-static'\n\nconst NAME = '__name__'\n\nexport default {\n  error (msg) {\n    throw new Error(`[${NAME}] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[${NAME}] ${msg}`)\n    }\n  },\n  assertModule (vuet, path) {\n    if (path in vuet.modules) {\n      return\n    }\n    this.error(`The '${path}' module does not exist`)\n  },\n  assertVue () {\n    if (!_Vue) {\n      this.error('must call Vue.use(Vuet) before creating a store instance')\n    }\n  },\n  assertFetch (vuet, path) {\n    this.assertModule(vuet, path)\n    if (typeof vuet.getModule(path).fetch !== 'function') {\n      this.error(`'${path}' module 'fetch' must be the function type`)\n    }\n  }\n}\n","import debug from '../../../src/debug'\n\nconst getName = (path) => {\n  return `__vuet_store_${path}__`\n}\n\nconst setItem = (path, data) => {\n  setTimeout(() => {\n    localStorage.setItem(getName(path), JSON.stringify(data))\n  }, 0)\n}\n\nexport default {\n  addModule (vuet, path) {\n    const store = JSON.parse(localStorage.getItem(getName(path)))\n    if (store) {\n      vuet.getModule(path).state = store\n    }\n  },\n  rule ({ path }) {\n    return {\n      created () {\n        debug.assertModule(this.$vuet, path)\n        setItem(path, this.$vuet.getModule(path).state)\n        this[getName(path)] = this.$vuet.app.$watch(function () {\n          return this.$vuet.getModule(path).state\n        }, (newVal) => {\n          setItem(path, newVal)\n        }, {\n          deep: true\n        })\n      },\n      destroyed () {\n        this[getName(path)]()\n        delete this[getName(path)]\n      }\n    }\n  }\n}\n"],"names":["msg","Error","vuet","path","modules","error","assertModule","getModule","fetch","getName","setItem","data","JSON","stringify","store","parse","localStorage","getItem","state","this","$vuet","app","$watch","newVal"],"mappings":"wMAGO,uBCEEA,QACC,IAAIC,uBAAmBD,kBAEzBA,2BAKQE,EAAMC,GACdA,IAAQD,GAAKE,cAGZC,cAAcF,wDAIZE,MAAM,kFAGFH,EAAMC,QACZG,aAAaJ,EAAMC,GACkB,kBAA/BD,GAAKK,UAAUJ,GAAMK,YACzBH,UAAUF,kDCzBfM,EAAU,SAACN,yBACQA,QAGnBO,EAAU,SAACP,EAAMQ,cACV,wBACID,QAAQD,EAAQN,GAAOS,KAAKC,UAAUF,KAClD,0BAIQT,EAAMC,MACTW,GAAQF,KAAKG,MAAMC,aAAaC,QAAQR,EAAQN,IAClDW,OACGP,UAAUJ,GAAMe,MAAQJ,wBAGzBX,KAAAA,iCAGIG,aAAaa,KAAKC,MAAOjB,KACvBA,EAAMgB,KAAKC,MAAMb,UAAUJ,GAAMe,YACpCT,EAAQN,IAASgB,KAAKC,MAAMC,IAAIC,OAAO,iBACnCH,MAAKC,MAAMb,UAAUJ,GAAMe,OACjC,SAACK,KACMpB,EAAMoB,WAER,+BAIHd,EAAQN,YACNgB,MAAKV,EAAQN"}